---
description: 
globs: 
alwaysApply: false
---
---
description: KuzuMem-MCP Memory Managemenet Guidelines
globs: 
alwaysApply: true
---

# KuzuMem-MCP Memory Management

## Memory Bank Lifecycle

### 1. Initialization
Use when starting work on a new repository or branch:

```json
{
  "tool": {
    "name": "memory-bank",
    "arguments": {
      "operation": "init",
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main"
    }
  }
}
```

**When to use:**
- New repository setup
- First time working on a branch
- After confirming user wants memory bank created

### 2. Metadata Management

**Get repository information:**
```json
{
  "tool": {
    "name": "memory-bank",
    "arguments": {
      "operation": "get-metadata",
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main"
    }
  }
}
```

**Update repository metadata:**
```json
{
  "tool": {
    "name": "memory-bank", 
    "arguments": {
      "operation": "update-metadata",
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main",
      "metadata": {
        "id": "meta",
        "project": {
          "name": "My App",
          "created": "2024-12-10",
          "description": "E-commerce platform"
        },
        "tech_stack": {
          "backend": "Node.js",
          "frontend": "React",
          "database": "KuzuDB"
        },
        "architecture": "microservices",
        "memory_spec_version": "1.0"
      }
    }
  }
}
```

## Context Management

### 1. Session Context
Query recent work context at session start:

```json
{
  "tool": {
    "name": "query",
    "arguments": {
      "type": "context",
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app", 
      "branch": "feature/auth",
      "latest": true,
      "limit": 10
    }
  }
}
```

### 2. Context Updates
Record significant work progress:

```json
{
  "tool": {
    "name": "context",
    "arguments": {
      "operation": "update",
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "feature/auth",
      "agent": "cursor",
      "summary": "Implemented OAuth2 authentication flow",
      "observation": "Added AuthService component with JWT token handling and refresh logic"
    }
  }
}
```

**Update triggers:**
- Completing a major feature
- Making architectural changes
- Discovering important patterns or issues
- End of work session

## Entity Management

### 1. Components
Represent system modules, services, or major code units:

```json
{
  "tool": {
    "name": "entity",
    "arguments": {
      "operation": "create",
      "entityType": "component",
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "feature/auth",
      "data": {
        "id": "comp-AuthService",
        "name": "Authentication Service", 
        "kind": "service",
        "depends_on": ["comp-UserRepository", "comp-TokenService"],
        "status": "active"
      }
    }
  }
}
```

**Component kinds:** `service`, `repository`, `controller`, `utility`, `middleware`, `model`

### 2. Decisions
Record architectural and technical decisions:

```json
{
  "tool": {
    "name": "entity",
    "arguments": {
      "operation": "create",
      "entityType": "decision",
      "clientProjectRoot": "/workspace/project", 
      "repository": "my-app",
      "branch": "feature/auth",
      "data": {
        "id": "dec-20241210-jwt-tokens",
        "name": "Use JWT for session tokens",
        "context": "Needed stateless authentication for microservices architecture",
        "date": "2024-12-10"
      }
    }
  }
}
```

**Decision ID format:** `dec-YYYYMMDD-descriptive-slug`

### 3. Rules
Define coding standards and architectural constraints:

```json
{
  "tool": {
    "name": "entity",
    "arguments": {
      "operation": "create",
      "entityType": "rule",
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app", 
      "branch": "main",
      "data": {
        "id": "rule-security-authentication",
        "name": "All API endpoints must be authenticated",
        "created": "2024-12-10",
        "triggers": ["api", "endpoint", "route"],
        "content": "Every API endpoint must validate JWT tokens except for /health and /login endpoints",
        "status": "active"
      }
    }
  }
}
```

## Best Practices

### 1. Component Dependencies
Always specify accurate `depends_on` relationships:

```json
{
  "depends_on": [
    "comp-DatabaseConnection",
    "comp-Logger", 
    "comp-ConfigService"
  ]
}
```

This enables impact analysis and dependency tracking.

### 2. Component Status
Use appropriate status values:
- `active` - Currently in use
- `deprecated` - Being phased out
- `planned` - Future implementation

### 3. Context Timing
Update context at these key moments:
- **Start of session:** Get latest context
- **Feature completion:** Record what was accomplished
- **Architecture changes:** Document new patterns
- **End of session:** Summarize work done

### 4. Branch-Specific Entities
- **Components:** Create per branch for new features
- **Decisions:** Usually branch-specific for feature decisions
- **Rules:** Often apply to main branch for consistency

## Common Workflows

### New Feature Development
1. Use `query` with `type: "context"` - Understand current state
2. Use `entity` with `operation: "create"` - Define new feature components
3. Use `entity` with `operation: "create"` - Record key design decisions
4. Use `context` with `operation: "update"` - Track progress throughout

### Refactoring Session  
1. Use `query` with `type: "dependencies"` - Understand current structure
2. Use `entity` to create decision - Document refactoring approach
3. Use `entity` to update components - Create new/updated components
4. Use `context` to update - Record refactoring progress

### Code Review Preparation
1. Use `query` with `type: "context"` - Review recent changes
2. Use `query` with `type: "governance"` - Check standards compliance
3. Use `entity` to create rule - Document new standards if needed