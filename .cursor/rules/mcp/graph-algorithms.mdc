---
description: 
globs: 
alwaysApply: false
---
---
description: KuzuMem-MCP Graph Algorithm usage
globs: 
alwaysApply: true
---
# KuzuMem-MCP Graph Algorithms

## System Analysis Algorithms

### 1. PageRank - Component Importance
Identify the most critical components in your system:

```json
{
  "tool": {
    "name": "pagerank",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main",
      "projectedGraphName": "component-importance",
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}
```

**Returns:** Components ranked by importance (PageRank score)
**Use case:** 
- Identify system bottlenecks
- Prioritize testing and documentation efforts
- Find components that need extra attention during changes

### 2. Community Detection - System Modules
Discover natural groupings and modules in your architecture:

```json
{
  "tool": {
    "name": "louvain-community-detection",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app", 
      "branch": "main",
      "projectedGraphName": "system-modules",
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}
```

**Returns:** Components grouped into logical modules/communities
**Use case:**
- Identify microservice boundaries
- Plan refactoring into separate modules
- Understand system architecture patterns

### 3. K-Core Decomposition - Cohesive Clusters
Find tightly coupled component clusters:

```json
{
  "tool": {
    "name": "k-core-decomposition",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main", 
      "projectedGraphName": "tight-coupling",
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"],
      "k": 2
    }
  }
}
```

**Parameters:**
- `k`: Minimum degree (2-4 typical values)
- Higher k = more tightly coupled clusters

**Use case:** Find components that are highly interdependent

## Dependency Analysis Algorithms

### 1. Strongly Connected Components - Circular Dependencies
Detect circular dependency issues:

```json
{
  "tool": {
    "name": "strongly-connected-components",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main",
      "projectedGraphName": "circular-deps",
      "nodeTableNames": ["Component"], 
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}
```

**Returns:** Groups of components with circular dependencies
**Use case:** 
- Identify architecture problems
- Plan dependency refactoring
- Find potential deadlock situations

### 2. Weakly Connected Components - Isolated Subsystems
Find isolated parts of your system:

```json
{
  "tool": {
    "name": "weakly-connected-components",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main",
      "projectedGraphName": "isolated-systems",
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}
```

**Returns:** Separate component islands with no connections
**Use case:**
- Find unused or orphaned components
- Identify potential candidates for service extraction
- Understand system modularity

### 3. Shortest Path - Relationship Tracing
Find how two components are connected:

```json
{
  "tool": {
    "name": "shortest-path",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main",
      "projectedGraphName": "connection-path",
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"],
      "startNodeId": "comp-UserInterface",
      "endNodeId": "comp-Database"
    }
  }
}
```

**Returns:** Shortest dependency path between two components
**Use case:**
- Understand how changes propagate
- Trace request flows through the system
- Plan integration strategies

## Multi-Entity Analysis

### 1. Cross-Entity Analysis
Analyze relationships across different entity types:

```json
{
  "tool": {
    "name": "pagerank",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main",
      "projectedGraphName": "governance-importance",
      "nodeTableNames": ["Component", "Decision", "Rule"],
      "relationshipTableNames": ["DEPENDS_ON", "GOVERNED_BY"]
    }
  }
}
```

**Use case:** Find the most influential decisions and rules

### 2. Governance Network Analysis
Understand rule and decision relationships:

```json
{
  "tool": {
    "name": "louvain-community-detection",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main",
      "projectedGraphName": "governance-domains",
      "nodeTableNames": ["Component", "Rule", "Decision"],
      "relationshipTableNames": ["GOVERNED_BY", "INFLUENCES"]
    }
  }
}
```

**Use case:** Group related governance concerns

## Algorithm Selection Guide

### System Health Analysis
```json
// 1. Find critical components (high PageRank)
{
  "tool": {
    "name": "pagerank",
    "arguments": {
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}

// 2. Check for circular dependencies
{
  "tool": {
    "name": "strongly-connected-components", 
    "arguments": {
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}

// 3. Find isolated components
{
  "tool": {
    "name": "weakly-connected-components",
    "arguments": {
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}
```

### Architecture Planning
```json
// 1. Discover natural modules
{
  "tool": {
    "name": "louvain-community-detection",
    "arguments": {
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}

// 2. Find tightly coupled clusters
{
  "tool": {
    "name": "k-core-decomposition",
    "arguments": {
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"],
      "k": 3
    }
  }
}
```

## Performance Considerations

### 1. Algorithm Complexity
- **PageRank:** Good for <1000 components
- **Community Detection:** Scales well, use for large systems
- **Shortest Path:** Fast, good for real-time queries
- **K-Core:** Medium complexity, use selectively

### 2. Progress Handling
Long-running algorithms may take time:
1. Inform user that analysis is running
2. Stream progress updates if available
3. Present results with clear explanations

### 3. Result Interpretation
- **PageRank scores:** Higher = more important/central
- **Community IDs:** Same ID = same module/group
- **Path lengths:** Shorter = more direct relationship
- **Core numbers:** Higher = more tightly coupled

## Best Practices

### 1. Algorithm Timing
- Run PageRank periodically (weekly/monthly)
- Check circular dependencies before major releases
- Use community detection for architecture reviews
- Run shortest path for specific impact analysis

### 2. Result Storage
Consider persisting algorithm results as components:
```json
{
  "tool": {
    "name": "add-component",
    "arguments": {
      "id": "comp-AnalysisResults-PageRank-20241209",
      "name": "PageRank Analysis Results",
      "kind": "analysis",
      "status": "active"
    }
  }
}
```

### 3. Interpretation Guidelines
- Focus on actionable insights from results
- Combine multiple algorithms for comprehensive analysis
- Use results to guide architectural decisions
- Document significant findings as decisions