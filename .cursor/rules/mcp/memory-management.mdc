---
description: 
globs: 
alwaysApply: false
---
---
description: KuzuMem-MCP Memory Managemenet Guidelines
globs: 
alwaysApply: true
---

# KuzuMem-MCP Memory Management

## Memory Bank Lifecycle

### 1. Initialization
Use when starting work on a new repository or branch:

```json
{
  "tool": {
    "name": "init-memory-bank",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main"
    }
  }
}
```

**When to use:**
- New repository setup
- First time working on a branch
- After confirming user wants memory bank created

### 2. Metadata Management

**Get repository information:**
```json
{
  "tool": {
    "name": "get-metadata",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main"
    }
  }
}
```

**Update repository metadata:**
```json
{
  "tool": {
    "name": "update-metadata", 
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "main",
      "metadata": {
        "techStack": ["Node.js", "TypeScript", "Kuzu"],
        "architecture": "microservices",
        "lastUpdated": "2024-12-09"
      }
    }
  }
}
```

## Context Management

### 1. Session Context
Query recent work context at session start:

```json
{
  "tool": {
    "name": "get-context",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app", 
      "branch": "feature/auth",
      "latest": true,
      "limit": 10
    }
  }
}
```

### 2. Context Updates
Record significant work progress:

```json
{
  "tool": {
    "name": "update-context",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "feature/auth",
      "agent": "cursor",
      "summary": "Implemented OAuth2 authentication flow",
      "observation": "Added AuthService component with JWT token handling and refresh logic"
    }
  }
}
```

**Update triggers:**
- Completing a major feature
- Making architectural changes
- Discovering important patterns or issues
- End of work session

## Entity Management

### 1. Components
Represent system modules, services, or major code units:

```json
{
  "tool": {
    "name": "add-component",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app",
      "branch": "feature/auth",
      "id": "comp-AuthService",
      "name": "Authentication Service", 
      "kind": "service",
      "dependsOn": ["comp-UserRepository", "comp-TokenService"],
      "status": "active"
    }
  }
}
```

**Component kinds:** `service`, `repository`, `controller`, `utility`, `middleware`, `model`

### 2. Decisions
Record architectural and technical decisions:

```json
{
  "tool": {
    "name": "add-decision",
    "arguments": {
      "clientProjectRoot": "/workspace/project", 
      "repository": "my-app",
      "branch": "feature/auth",
      "id": "dec-20241209-jwt-tokens",
      "name": "Use JWT for session tokens",
      "context": "Needed stateless authentication for microservices architecture",
      "date": "2024-12-09"
    }
  }
}
```

**Decision ID format:** `dec-YYYYMMDD-descriptive-slug`

### 3. Rules
Define coding standards and architectural constraints:

```json
{
  "tool": {
    "name": "add-rule",
    "arguments": {
      "clientProjectRoot": "/workspace/project",
      "repository": "my-app", 
      "branch": "main",
      "id": "rule-security-authentication",
      "name": "All API endpoints must be authenticated",
      "created": "2024-12-09",
      "triggers": ["api", "endpoint", "route"],
      "content": "Every API endpoint must validate JWT tokens except for /health and /login endpoints",
      "status": "active"
    }
  }
}
```

## Best Practices

### 1. Component Dependencies
Always specify accurate `dependsOn` relationships:

```json
{
  "dependsOn": [
    "comp-DatabaseConnection",
    "comp-Logger", 
    "comp-ConfigService"
  ]
}
```

This enables impact analysis and dependency tracking.

### 2. Component Status
Use appropriate status values:
- `active` - Currently in use
- `deprecated` - Being phased out
- `planned` - Future implementation

### 3. Context Timing
Update context at these key moments:
- **Start of session:** Get latest context
- **Feature completion:** Record what was accomplished
- **Architecture changes:** Document new patterns
- **End of session:** Summarize work done

### 4. Branch-Specific Entities
- **Components:** Create per branch for new features
- **Decisions:** Usually branch-specific for feature decisions
- **Rules:** Often apply to main branch for consistency

## Common Workflows

### New Feature Development
1. `get-context` - Understand current state
2. `add-component` - Define new feature components
3. `add-decision` - Record key design choices
4. `update-context` - Track progress throughout development

### Refactoring Session  
1. `get-component-dependencies` - Understand current structure
2. `add-decision` - Document refactoring approach
3. `add-component` - Create new/updated components
4. `update-context` - Record refactoring progress

### Code Review Preparation
1. `get-context` - Review recent changes
2. `get-governing-items-for-component` - Check standards compliance
3. `add-rule` - Document new standards if needed