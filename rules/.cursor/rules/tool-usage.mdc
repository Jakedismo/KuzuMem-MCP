---
description: 
globs: 
alwaysApply: false
---
# Cursor MCP Tool Usage Rule

## 1. Tool System Overview
- MCP tools are the primary interface for interacting with the project knowledge graph (KuzuMem-MCP).
- Tools are defined in [`src/mcp/tools/`](mdc:src/mcp/tools) and catalogued in [`index.ts`](mdc:src/mcp/tools/index.ts).
- The system now provides **11 unified tools** (consolidated from 29) with consistent parameter patterns.
- Each tool has a canonical name, parameter schema, and return type. Use canonical names exactly as defined.

## 2. When to Use a Tool
- Use a tool whenever you need to **read from** or **write to** the project memory graph (context, metadata, components, decisions, rules, relationships, or graph analytics).
- Prefer tool calls over direct DB or file access—tools enforce branch isolation, audit, and response formatting.
- For all graph traversal, context/history, or analytics (e.g., dependencies, PageRank, community detection), use the corresponding tool.
- For memory bank setup or metadata, use the memory-bank tool with appropriate operations.

## 3. Tool Invocation Patterns
- Always include `repository` and `branch` in tool arguments (branch defaults to 'main' if not specified).
- For entity operations, use the `entity` tool with `operation` and `entityType` parameters.
- For queries, use the `query` tool with appropriate `type` parameter.
- For graph algorithms, use `analyze` or `detect` tools with algorithm `type`.
- Never call tools with incomplete or ambiguous arguments—validate input first.

## 4. Progressive/Streaming Tools
- Some tools support progressive results via the `tools/progress` channel.
  - Use these for long-running graph operations (e.g., PageRank, traversal, community detection).
  - Inform the user if an operation may take time and stream progress if supported by the transport.
  - Handle `isFinal: true` notifications as the completion signal.
- Always present the final result in a user-friendly summary, and explain intermediate results if asked.

## 5. Unified Tool Reference

### The 11 Unified Tools:

1. **memory-bank** - Initialize and manage memory bank metadata
2. **entity** - Create, update, delete, and retrieve all entity types
3. **introspect** - Explore graph schema and metadata
4. **context** - Manage work session context
5. **query** - Unified search across all query types
6. **associate** - Create relationships between entities
7. **analyze** - Run graph algorithms
8. **detect** - Detect patterns in the graph
9. **bulk-import** - Efficient bulk entity import
10. **search** - Standard search capabilities
11. **semantic-search** - Semantic search (placeholder)

### Tool Selection Guide:

| Use Case                        | Tool Name | Parameters                          |
|----------------------------------|-----------|-------------------------------------|
| Initialize memory bank           | `memory-bank` | `operation: "init"`             |
| Get/update repo metadata         | `memory-bank` | `operation: "get-metadata"/"update-metadata"` |
| Add/update context               | `context` | `operation: "update"`             |
| Create entities                  | `entity` | `operation: "create", entityType: "component"/"decision"/"rule"/"file"/"tag"` |
| Update/delete entities           | `entity` | `operation: "update"/"delete"`   |
| Get dependencies/dependents      | `query` | `type: "dependencies", direction: "dependencies"/"dependents"` |
| Get contextual history           | `query` | `type: "history"`                 |
| Get governing items              | `query` | `type: "governance"`              |
| Get related items                | `query` | `type: "relationships"`           |
| Run PageRank                     | `analyze` | `type: "pagerank"`                |
| Run community detection          | `analyze` | `type: "louvain"`                 |
| Find shortest path               | `analyze` | `type: "shortest-path"`           |
| Find strongly connected          | `detect` | `type: "strongly-connected"`      |
| Find weakly connected            | `detect` | `type: "weakly-connected"`        |

## 6. Best Practices
- Validate all arguments before tool invocation.
- Never leak secrets or personal data in tool calls.
- Use the tool's return schema to structure your response.
- For any operation not covered by a tool, escalate or refuse.
- Log every write operation for auditability.
- Use the unified tools—legacy individual tools have been removed.

## 7. Example Tool Calls

### Creating a Component:
```json
{
  "tool": {
    "name": "entity",
    "arguments": {
      "operation": "create",
      "entityType": "component",
      "repository": "my-repo",
      "branch": "feature-x",
      "data": {
        "id": "comp-auth-service",
        "name": "Authentication Service",
        "kind": "service",
        "depends_on": ["comp-user-service"]
      }
    }
  }
}
```

### Querying Dependencies:
```json
{
  "tool": {
    "name": "query",
    "arguments": {
      "type": "dependencies",
      "repository": "my-repo",
      "branch": "feature-x",
      "componentId": "comp-auth-service",
      "direction": "dependencies"
    }
  }
}
```

### Running PageRank Analysis:
```json
{
  "tool": {
    "name": "analyze",
    "arguments": {
      "type": "pagerank",
      "repository": "my-repo",
      "branch": "main",
      "projectedGraphName": "component-importance",
      "nodeTableNames": ["Component"],
      "relationshipTableNames": ["DEPENDS_ON"]
    }
  }
}
```
