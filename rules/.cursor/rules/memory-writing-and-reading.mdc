---
description: 
globs: 
alwaysApply: true
---
# Cursor Rule: Memory Writing and Reading During Development

## 1. When to **Write** Memories
Write a memory to the KuzuMem-MCP graph **immediately after** any of the following events:

| Event/Trigger                                 | Tool to Use         | Operation/Parameters                                     |
|-----------------------------------------------|---------------------|----------------------------------------------------------|
| You complete a significant code edit          | `context`           | `operation: "update"`, summary, observation              |
| You resolve a bug or discover a pattern       | `context`           | `operation: "update"`, bug pattern, fix summary          |
| You make a key architectural decision         | `entity`            | `operation: "create", entityType: "decision"`            |
| You add or refactor a module/component        | `entity`            | `operation: "create", entityType: "component"`           |
| You establish or update a coding rule/standard| `entity`            | `operation: "create", entityType: "rule"`                |
| You update repository-level metadata          | `memory-bank`       | `operation: "update-metadata"`                           |

**Best Practice:**  
- Always include the current `repository` and `branch` in every tool call.
- Write memories as soon as the event occursâ€”do not batch or delay.
- Use the most specific tool and operation for the memory type (see table above).
- Never write to the `main` branch unless explicitly instructed.

---

## 2. When to **Read** Memories
Read from the memory graph at these key moments:

| Development Moment                           | Tool to Use         | Query Type/Parameters                                    |
|----------------------------------------------|---------------------|----------------------------------------------------------|
| At the start of a coding session             | `query`             | `type: "context", latest: true`                         |
| Before making a design or architectural change| `entity`           | `operation: "get", entityType: "decision"`               |
| When working on or refactoring a component   | `query`             | `type: "dependencies"` or `type: "history"`             |
| When reviewing or enforcing standards        | `query`             | `type: "governance"` for rules and decisions            |
| When debugging or investigating regressions  | `query`             | `type: "context"` or `type: "history"`                  |

**Best Practice:**  
- Always query the latest context before starting new work.
- Use the `query` tool with appropriate `type` for complex searches.
- Use the `entity` tool with `operation: "get"` for direct entity retrieval.

---

## 3. Unified Tool Reference
| Memory Type      | Write Tool         | Write Operation     | Read Tool    | Read Operation/Type    |
|------------------|--------------------|---------------------|--------------|------------------------|
| Context/Note     | `context`          | `operation: "update"` | `query`      | `type: "context"`      |
| Component        | `entity`           | `operation: "create", entityType: "component"` | `query` | `type: "dependencies"` |
| Decision         | `entity`           | `operation: "create", entityType: "decision"` | `query` | `type: "governance"`   |
| Rule             | `entity`           | `operation: "create", entityType: "rule"` | `query` | `type: "governance"`   |
| Metadata         | `memory-bank`      | `operation: "update-metadata"` | `memory-bank` | `operation: "get-metadata"` |

---

## 4. General Guidance
- **Write** memories for every meaningful change, insight, or decision.
- **Read** memories to inform every new task, design, or investigation.
- Use the **unified tools** with appropriate operations and types.
- **Never** store secrets, credentials, or personal data.
- **Log** every write for auditability.

---

## 5. When to Use Graph Analysis Tools
Use the following analysis and detection tools to analyze, traverse, or understand the structure and relationships within your project knowledge graph:

| Tool & Type                      | When to Use / Scenario                                                                 |
|----------------------------------|--------------------------------------------------------------------------------------|
| `query` (type: "dependencies")    | To find all upstream dependencies or downstream dependents of a component             |
| `query` (type: "relationships")   | To explore all items related to a given item within a certain relationship depth      |
| `query` (type: "history")         | To retrieve all context items linked to a specific component, decision, or rule       |
| `query` (type: "governance")      | To find all decisions and rules governing a component                                |
| `detect` (type: "strongly-connected") | To detect cycles or tightly coupled feedback loops in the graph                   |
| `detect` (type: "weakly-connected")   | To identify isolated clusters or "islands" in the project graph                   |
| `analyze` (type: "pagerank")      | To identify the most influential or central items in the project knowledge graph      |
| `analyze` (type: "louvain")       | To discover natural communities or thematic clusters among memory items               |
| `analyze` (type: "k-core")        | To find highly interconnected subgraphs (core project areas)                          |
| `analyze` (type: "shortest-path") | To find the most direct relationship or sequence of connections between two items     |

**Best Practice:**
- Use the `query` tool for standard traversals and relationships.
- Use the `analyze` tool for complex graph algorithms requiring projection.
- Use the `detect` tool for pattern detection like cycles or islands.
- For large or complex queries, inform the user that the operation may take time.
- Always include `repository` and `branch` in every call.

---

## 6. Example Tool Calls

### Writing Context:
```json
{
  "tool": {
    "name": "context",
    "arguments": {
      "operation": "update",
      "repository": "my-app",
      "branch": "feature/auth",
      "agent": "cursor",
      "summary": "Implemented JWT authentication",
      "observation": "Used refresh token pattern for better security"
    }
  }
}
```

### Creating a Decision:
```json
{
  "tool": {
    "name": "entity",
    "arguments": {
      "operation": "create",
      "entityType": "decision",
      "repository": "my-app",
      "branch": "main",
      "data": {
        "id": "dec-20241210-auth-strategy",
        "name": "JWT Authentication Strategy",
        "date": "2024-12-10",
        "context": "Needed stateless auth for microservices"
      }
    }
  }
}
```

### Querying Dependencies:
```json
{
  "tool": {
    "name": "query",
    "arguments": {
      "type": "dependencies",
      "repository": "my-app",
      "branch": "main",
      "componentId": "comp-auth-service",
      "direction": "dependents"
    }
  }
}
```
