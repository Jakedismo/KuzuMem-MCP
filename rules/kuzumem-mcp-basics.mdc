---
description: 
globs: 
alwaysApply: false
---
---
description: KuzuMem-MCP Core Usage Guidelines
globs: 
alwaysApply: true
---

# KuzuMem-MCP Server - Core Usage

## Overview

You are working with a **KuzuMem-MCP Server** that provides persistent, graph-based memory storage for AI coding assistants. The server uses the **official MCP TypeScript SDK** with full protocol compliance. The system now provides **11 unified tools** (consolidated from 29) with consistent parameter patterns.

## Essential Parameters

**Every MCP tool call MUST include:**
- `clientProjectRoot`: Absolute path to the client project (e.g., `"/path/to/project"`)
- `repository`: Repository name (e.g., `"my-app"`)  
- `branch`: Git branch name (defaults to `"main"`)

## Tool Call Format

Use this exact JSON structure for tool calls:

```json
{
  "tool": {
    "name": "tool-name",
    "arguments": {
      "clientProjectRoot": "/path/to/project",
      "repository": "repository-name", 
      "branch": "branch-name",
      // ... additional tool-specific arguments
    }
  }
}
```

## The 11 Unified Tools

### 1. **memory-bank** - Initialize and manage memory bank metadata
- Operations: `init`, `get-metadata`, `update-metadata`

### 2. **entity** - Create, update, delete, and retrieve all entity types
- Operations: `create`, `get`, `update`, `delete`
- Entity types: `component`, `decision`, `rule`, `file`, `tag`

### 3. **introspect** - Explore graph schema and metadata
- Query types: `labels`, `count`, `properties`, `indexes`

### 4. **context** - Manage work session context
- Operations: `update` (get is via `query` tool)

### 5. **query** - Unified search across all query types
- Types: `context`, `entities`, `relationships`, `dependencies`, `governance`, `history`, `tags`

### 6. **associate** - Create relationships between entities
- Types: `file-component`, `tag-item`

### 7. **analyze** - Run graph algorithms
- Types: `pagerank`, `shortest-path`, `k-core`, `louvain`

### 8. **detect** - Detect patterns in the graph
- Types: `strongly-connected`, `weakly-connected`

### 9. **bulk-import** - Efficient bulk entity import
- Types: `components`, `decisions`, `rules`

### 10. **search** - Standard search capabilities

### 11. **semantic-search** - Semantic search (placeholder)

## Basic Workflow

1. **Initialize** (if needed): Use `memory-bank` with `operation: "init"`
2. **Query Context**: Use `query` with `type: "context"` to understand current state  
3. **Perform Work**: Use appropriate tools based on the task
4. **Update Memory**: Use `context` for updates, `entity` for creating/updating entities

## ID Naming Conventions

- **Components**: `comp-{Name}` (e.g., `comp-AuthService`)
- **Decisions**: `dec-{YYYYMMDD}-{slug}` (e.g., `dec-20241210-api-versioning`)  
- **Rules**: `rule-{category}-{description}` (e.g., `rule-security-authentication`)
- **Files**: `file-{path-slug}-v{version}` (e.g., `file-src-auth-service-ts-v1`)
- **Tags**: `tag-{category}-{name}` (e.g., `tag-security-critical`)

## Response Formats

The server returns results in MCP-compliant format:
- Success: Tool-specific response schemas
- Error: `{"error": {"code": -32603, "message": "Error description"}}`

All unified tools return structured responses specific to their operation.

## Example: Creating a Component

```json
{
  "tool": {
    "name": "entity",
    "arguments": {
      "operation": "create",
      "entityType": "component",
      "clientProjectRoot": "/workspace/my-project",
      "repository": "ecommerce-api",
      "branch": "feature/checkout",
      "data": {
        "id": "comp-PaymentService",
        "name": "Payment Service",
        "kind": "service",
        "depends_on": ["comp-OrderService", "comp-UserService"],
        "status": "active"
      }
    }
  }
}
```

## Example: Querying Dependencies

```json
{
  "tool": {
    "name": "query",
    "arguments": {
      "type": "dependencies",
      "clientProjectRoot": "/workspace/my-project",
      "repository": "ecommerce-api",
      "branch": "feature/checkout",
      "componentId": "comp-PaymentService",
      "direction": "dependencies"
    }
  }
}
```

## Tool Consolidation Benefits

- **Simplified Integration**: 11 tools instead of 29
- **Consistent Parameters**: All tools follow similar patterns
- **Better Maintainability**: Reduced complexity
- **Type Safety**: Full TypeScript support with no compilation errors